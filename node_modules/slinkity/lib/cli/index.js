#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/utils/logger.js
var require_logger = __commonJS({
  "src/utils/logger.js"(exports2, module2) {
    var chalk = require("chalk");
    module2.exports = {
      log({ type = "info", message = "" }) {
        if (type === "error") {
          console.log(chalk.red(`[Error] ${message}`));
        } else if (type === "warning") {
          console.log(chalk.yellow(`[Warning] ${message}`));
        } else {
          console.log(chalk.blue(`[Info] ${message}`));
        }
      }
    };
  }
});

// src/utils/resolveConfigFilePath.js
var require_resolveConfigFilePath = __commonJS({
  "src/utils/resolveConfigFilePath.js"(exports2, module2) {
    var { resolve: resolve2 } = require("path");
    var { readFile } = require("fs").promises;
    async function resolveConfigFilePath(files) {
      for (const file of files) {
        try {
          const path = resolve2(file);
          await readFile(path);
          return path;
        } catch {
        }
      }
      return void 0;
    }
    module2.exports = {
      resolveConfigFilePath
    };
  }
});

// src/utils/consts.js
var require_consts = __commonJS({
  "src/utils/consts.js"(exports2, module2) {
    var SLINKITY_ATTRS = {
      id: "data-s-id",
      ssr: "data-s-needs-ssr"
    };
    var IMPORT_ALIASES = {
      root: "/@root",
      input: "/@input",
      includes: "/@includes",
      layouts: "/@layouts"
    };
    var PACKAGES = {
      client: "slinkity/client"
    };
    var SLINKITY_REACT_MOUNT_POINT = "slinkity-react-mount-point";
    var SLINKITY_CONFIG_FILE_NAME = "slinkity.config";
    module2.exports = {
      SLINKITY_ATTRS,
      SLINKITY_CONFIG_FILE_NAME,
      SLINKITY_REACT_MOUNT_POINT,
      IMPORT_ALIASES,
      PACKAGES
    };
  }
});

// src/cli/vite.js
var require_vite = __commonJS({
  "src/cli/vite.js"(exports2, module2) {
    var vite = require("vite");
    var { join } = require("path");
    var { promisify } = require("util");
    var glob = promisify(require("glob"));
    var { resolveConfigFilePath } = require_resolveConfigFilePath();
    var { IMPORT_ALIASES } = require_consts();
    function getConfigFile() {
      return resolveConfigFilePath(["js", "mjs", "ts"].map((ext) => `vite.config.${ext}`));
    }
    function getResolvedAliases({ input, includes, layouts }) {
      return {
        root: join(process.cwd()),
        input: join(process.cwd(), input),
        includes: join(process.cwd(), input, includes),
        layouts: join(process.cwd(), input, layouts)
      };
    }
    async function getSharedConfig(eleventyDir) {
      const importAliasesToResolvedPath = Object.entries(getResolvedAliases(eleventyDir)).map(([key, value]) => [IMPORT_ALIASES[key], value]);
      let reactConfig = vite.defineConfig();
      try {
        require("react");
        require("react-dom");
        reactConfig = vite.defineConfig({
          resolve: {
            dedupe: ["react", "react-dom"]
          },
          optimizeDeps: {
            include: ["react", "react/jsx-runtime", "react/jsx-dev-runtime", "react-dom"]
          },
          build: {
            rollupOptions: {
              output: {
                manualChunks: {
                  react: ["react"]
                }
              }
            }
          }
        });
      } catch {
      }
      return vite.mergeConfig(vite.defineConfig({
        clearScreen: false,
        configFile: await getConfigFile(),
        resolve: {
          alias: Object.fromEntries(importAliasesToResolvedPath)
        }
      }), reactConfig);
    }
    async function build({ eleventyDir, input, output }) {
      const inputFiles = await glob(`${input}/**/*.html`, { absolute: true });
      if (inputFiles.length) {
        await vite.build(vite.mergeConfig({
          root: input,
          build: {
            outDir: output,
            emptyOutDir: true,
            rollupOptions: {
              input: inputFiles
            }
          }
        }, await getSharedConfig(eleventyDir)));
      }
    }
    module2.exports = { build, getConfigFile, getSharedConfig, getResolvedAliases };
  }
});

// src/cli/toViteSSR.js
var require_toViteSSR = __commonJS({
  "src/cli/toViteSSR.js"(exports2, module2) {
    var { createServer, build, defineConfig } = require("vite");
    var requireFromString = require("require-from-string");
    var logger = require_logger();
    var { getSharedConfig } = require_vite();
    function gimmeCSSPlugin() {
      const styleToFilePathMap = {};
      return {
        getCSS() {
          return styleToFilePathMap;
        },
        plugin: {
          name: "gimme-css-plugin",
          transform(code, id) {
            if (/\.(css|scss|sass|less|stylus)$/.test(id)) {
              styleToFilePathMap[id] = code;
              return { code: "" };
            }
            return null;
          }
        }
      };
    }
    async function viteBuild2({ dir, ssrViteConfig, filePath, environment, generatedStyles }) {
      const { output } = await build(__spreadProps(__spreadValues(__spreadValues({}, ssrViteConfig), await getSharedConfig(dir)), {
        mode: environment,
        build: {
          ssr: true,
          write: false,
          rollupOptions: {
            input: filePath
          }
        }
      }));
      const mod = {
        default: () => null,
        getProps: () => ({}),
        frontMatter: {},
        __stylesGenerated: generatedStyles.getCSS()
      };
      if (!(output == null ? void 0 : output.length)) {
        logger.log({
          type: "error",
          message: `Module ${filePath} didn't have any output. Is this file blank?`
        });
        return mod;
      }
      return __spreadValues(__spreadValues({}, mod), requireFromString(output[0].code));
    }
    module2.exports = async function toViteSSR({ environment, dir }) {
      const generatedStyles = gimmeCSSPlugin();
      const ssrViteConfig = defineConfig({
        root: dir.output,
        plugins: [generatedStyles.plugin]
      });
      const probablyInefficientCache = {};
      if (environment === "dev") {
        let server = null;
        return {
          async toCommonJSModule(filePath, options2 = { useCache: false }) {
            if (options2.useCache && probablyInefficientCache[filePath]) {
              return probablyInefficientCache[filePath];
            }
            let viteOutput;
            if (server) {
              viteOutput = __spreadValues({
                default: () => null,
                getProps: () => ({}),
                frontMatter: {},
                __stylesGenerated: generatedStyles.getCSS()
              }, await server.ssrLoadModule(filePath));
            } else {
              viteOutput = await viteBuild2({
                dir,
                filePath,
                ssrViteConfig,
                generatedStyles,
                environment
              });
            }
            probablyInefficientCache[filePath] = viteOutput;
            return viteOutput;
          },
          getServer() {
            return server;
          },
          async createServer() {
            server = await createServer(__spreadProps(__spreadValues(__spreadValues({}, ssrViteConfig), await getSharedConfig(dir)), {
              server: {
                middlewareMode: "ssr"
              }
            }));
            return server;
          }
        };
      } else {
        return {
          async toCommonJSModule(filePath, options2 = { useCache: true }) {
            if (options2.useCache && probablyInefficientCache[filePath]) {
              return probablyInefficientCache[filePath];
            }
            const viteOutput = await viteBuild2({
              dir,
              filePath,
              generatedStyles,
              ssrViteConfig,
              environment
            });
            probablyInefficientCache[filePath] = viteOutput;
            return viteOutput;
          },
          getServer() {
            return null;
          },
          createServer() {
          }
        };
      }
    };
  }
});

// src/main/defineConfig.js
var require_defineConfig = __commonJS({
  "src/main/defineConfig.js"(exports2, module2) {
    function defineConfig(userConfig = {}) {
      var _a;
      return {
        eleventyIgnores: (_a = userConfig.eleventyIgnores) != null ? _a : (ignores) => ignores
      };
    }
    module2.exports = {
      defineConfig
    };
  }
});

// src/cli/readUserSlinkityConfig.js
var require_readUserSlinkityConfig = __commonJS({
  "src/cli/readUserSlinkityConfig.js"(exports2, module2) {
    var { resolveConfigFilePath } = require_resolveConfigFilePath();
    var { SLINKITY_CONFIG_FILE_NAME } = require_consts();
    var requireFromString = require("require-from-string");
    var { build } = require("esbuild");
    var logger = require_logger();
    var { defineConfig } = require_defineConfig();
    var supportedExts = ["js", "ts"];
    async function readUserSlinkityConfig() {
      const configFile = await resolveConfigFilePath(supportedExts.map((ext) => `${SLINKITY_CONFIG_FILE_NAME}.${ext}`));
      if (!configFile)
        return defineConfig();
      const { outputFiles } = await build({
        format: "cjs",
        entryPoints: [configFile],
        bundle: false,
        write: false
      });
      let config = requireFromString(outputFiles[0].text);
      if (config == null ? void 0 : config.default) {
        config = config.default;
      }
      if (typeof config === "function") {
        return defineConfig(await config());
      } else if (typeof config === "object" && config !== null) {
        return defineConfig(config);
      } else {
        logger.log({
          type: "error",
          message: "We expected your config to either return a function or an object. Double check that you are returning a valid config!"
        });
        return defineConfig();
      }
    }
    module2.exports = {
      readUserSlinkityConfig
    };
  }
});

// src/utils/toEscapedHtml.js
var require_toEscapedHtml = __commonJS({
  "src/utils/toEscapedHtml.js"(exports2, module2) {
    module2.exports = function toEscapedHtml(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
    };
  }
});

// src/utils/toHtmlAttrString.js
var require_toHtmlAttrString = __commonJS({
  "src/utils/toHtmlAttrString.js"(exports2, module2) {
    var toEscapedHtml = require_toEscapedHtml();
    module2.exports = function toHtmlAttrString(props = {}) {
      return Object.entries(props).reduce((htmlAttrs, [key, value]) => {
        return [...htmlAttrs, `${key}="${toEscapedHtml(`${value}`)}"`];
      }, []).join(" ");
    };
  }
});

// src/plugin/reactPlugin/1-pluginDefinitions/toMountPoint.js
var require_toMountPoint = __commonJS({
  "src/plugin/reactPlugin/1-pluginDefinitions/toMountPoint.js"(exports2, module2) {
    var { SLINKITY_ATTRS, SLINKITY_REACT_MOUNT_POINT } = require_consts();
    var toHtmlAttrString = require_toHtmlAttrString();
    function toMountPoint({ id, hydrate }) {
      const attrs = toHtmlAttrString({
        [SLINKITY_ATTRS.id]: id,
        [SLINKITY_ATTRS.ssr]: true
      });
      if (hydrate === "static") {
        return `<div ${attrs}></div>`;
      } else {
        return `<${SLINKITY_REACT_MOUNT_POINT} ${attrs}></${SLINKITY_REACT_MOUNT_POINT}>`;
      }
    }
    module2.exports = { toMountPoint };
  }
});

// src/plugin/reactPlugin/1-pluginDefinitions/addShortcode.js
var require_addShortcode = __commonJS({
  "src/plugin/reactPlugin/1-pluginDefinitions/addShortcode.js"(exports2, module2) {
    var { toMountPoint } = require_toMountPoint();
    var { join, extname } = require("path");
    var { log } = require_logger();
    var argsArrayToPropsObj = function({ vargs = [], errorMsg = "" }) {
      if (vargs.length % 2 !== 0) {
        log({ type: "warning", message: errorMsg });
        return {};
      }
      const props = {};
      for (let i = 0; i < vargs.length; i += 2) {
        const key = vargs[i];
        const value = vargs[i + 1];
        props[key] = value;
      }
      return props;
    };
    module2.exports = function addShortcode(eleventyConfig, { componentAttrStore, resolvedImportAliases }) {
      eleventyConfig.addShortcode("react", function(componentPath, ...vargs) {
        const absComponentPath = join(resolvedImportAliases.includes, componentPath) + (componentPath.endsWith(".jsx") ? "" : ".jsx");
        let props = {};
        if (typeof vargs[0] === "object") {
          props = vargs[0];
        } else {
          props = argsArrayToPropsObj({
            vargs,
            errorMsg: `Looks like you passed a "prop" key without a corresponding value.
  Check your props on react shortcode "${componentPath}"
  in file "${this.page.inputPath}"`
          });
        }
        const { render = "eager" } = props;
        const id = componentAttrStore.push({
          path: absComponentPath,
          props,
          hydrate: render,
          styleToFilePathMap: {},
          pageOutputPath: this.page.outputPath
        });
        const html = toMountPoint({ id, hydrate: render });
        if (extname(this.page.inputPath) === ".md" && render !== "static") {
          return `<div>${html}</div>`;
        } else {
          return html;
        }
      });
    };
    module2.exports.argsArrayToPropsObj = argsArrayToPropsObj;
  }
});

// src/plugin/reactPlugin/1-pluginDefinitions/toFormattedDataForProps.js
var require_toFormattedDataForProps = __commonJS({
  "src/plugin/reactPlugin/1-pluginDefinitions/toFormattedDataForProps.js"(exports2, module2) {
    function toFormattedDataForProps(eleventyData = {}) {
      const formattedCollections = {};
      for (let name of Object.keys(eleventyData.collections)) {
        formattedCollections[name] = eleventyData.collections[name].map((item) => {
          const _a = item.data, { collections } = _a, data = __objRest(_a, ["collections"]);
          return {
            inputPath: item.inputPath,
            fileSlug: item.fileSlug,
            filePathStem: item.filePathStem,
            date: item.date,
            outputPath: item.outputPath,
            url: item.url,
            data,
            get templateContent() {
              return item.templateContent;
            }
          };
        });
      }
      return __spreadProps(__spreadValues({}, eleventyData), {
        collections: formattedCollections
      });
    }
    module2.exports = toFormattedDataForProps;
  }
});

// src/plugin/reactPlugin/1-pluginDefinitions/addPageExtension.js
var require_addPageExtension = __commonJS({
  "src/plugin/reactPlugin/1-pluginDefinitions/addPageExtension.js"(exports2, module2) {
    var { toMountPoint } = require_toMountPoint();
    var toFormattedDataForProps = require_toFormattedDataForProps();
    var { join } = require("path");
    module2.exports = function addPageExtension(eleventyConfig, { componentAttrStore, viteSSR, resolvedImportAliases }) {
      let useCache = false;
      eleventyConfig.addExtension("jsx", {
        read: false,
        getData: async (inputPath) => {
          const absInputPath = join(resolvedImportAliases.root, inputPath);
          useCache = true;
          const { frontMatter } = await viteSSR.toCommonJSModule(absInputPath, { useCache });
          return frontMatter;
        },
        compile: (_, inputPath) => async function(data) {
          var _a, _b;
          const absInputPath = join(resolvedImportAliases.root, inputPath);
          const { getProps, frontMatter } = await viteSSR.toCommonJSModule(absInputPath, {
            useCache
          });
          const props = await getProps(toFormattedDataForProps(__spreadProps(__spreadValues({}, data), {
            shortcodes: (_a = eleventyConfig.javascriptFunctions) != null ? _a : {}
          })));
          const hydrate = (_b = frontMatter.render) != null ? _b : "eager";
          const id = componentAttrStore.push({
            path: absInputPath,
            props,
            styleToFilePathMap: {},
            hydrate,
            pageOutputPath: data.page.outputPath
          });
          return toMountPoint({ id, hydrate });
        }
      });
      eleventyConfig.on("afterBuild", () => {
        useCache = false;
      });
    };
  }
});

// src/plugin/reactPlugin/1-pluginDefinitions/index.js
var require_pluginDefinitions = __commonJS({
  "src/plugin/reactPlugin/1-pluginDefinitions/index.js"(exports2, module2) {
    var addShortcode = require_addShortcode();
    var addPageExtension = require_addPageExtension();
    module2.exports = {
      addShortcode,
      addPageExtension
    };
  }
});

// src/plugin/reactPlugin/index.js
var require_reactPlugin = __commonJS({
  "src/plugin/reactPlugin/index.js"(exports2, module2) {
    var { addPageExtension, addShortcode } = require_pluginDefinitions();
    module2.exports = function reactPlugin(eleventyConfig, { viteSSR, componentAttrStore, resolvedImportAliases }) {
      addPageExtension(eleventyConfig, { componentAttrStore, viteSSR, resolvedImportAliases });
      addShortcode(eleventyConfig, { componentAttrStore, resolvedImportAliases });
    };
  }
});

// src/utils/toSlashesTrimmed.js
var require_toSlashesTrimmed = __commonJS({
  "src/utils/toSlashesTrimmed.js"(exports2, module2) {
    module2.exports = function toSlashesTrimmed(url) {
      return url.replace(/^\/|\/$/g, "");
    };
  }
});

// src/plugin/componentAttrStore.js
var require_componentAttrStore = __commonJS({
  "src/plugin/componentAttrStore.js"(exports2, module2) {
    function toComponentAttrStore() {
      let componentAttrStore = {};
      function push(componentAttrs) {
        const { pageOutputPath } = componentAttrs;
        if (!componentAttrStore[pageOutputPath]) {
          componentAttrStore[pageOutputPath] = [];
        }
        const id = `${componentAttrStore[pageOutputPath].length}`;
        componentAttrStore[pageOutputPath].push(__spreadProps(__spreadValues({}, componentAttrs), { id }));
        return id;
      }
      function getAllByPage(pageOutputPath) {
        var _a;
        return (_a = componentAttrStore[pageOutputPath]) != null ? _a : [];
      }
      function clear() {
        componentAttrStore = {};
      }
      return {
        push,
        getAllByPage,
        clear
      };
    }
    module2.exports = { toComponentAttrStore };
  }
});

// src/plugin/reactPlugin/2-pageTransform/applyHtmlWrapper.js
var require_applyHtmlWrapper = __commonJS({
  "src/plugin/reactPlugin/2-pageTransform/applyHtmlWrapper.js"(exports2, module2) {
    module2.exports = function applyHtmlWrapper(rootElement) {
      let content = rootElement.innerHTML;
      const hasHtmlTag = Boolean(rootElement.querySelector("html"));
      const hasHead = Boolean(rootElement.querySelector("head"));
      const hasBody = Boolean(rootElement.querySelector("body"));
      if (!hasHtmlTag) {
        if (!hasBody) {
          content = toBodyWrapper(content);
        }
        rootElement.innerHTML = toHtmlWrapper(content, !hasHead);
      }
    };
    function toBodyWrapper(content) {
      return `<body>
  ${content}
</body>`;
    }
    function toHtmlWrapper(content, applyHead = true) {
      const head = `
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>`;
      return `<!DOCTYPE html>
<html lang="en">${applyHead ? head : ""}

${content}

</html>`;
    }
  }
});

// src/utils/toUnixPath.js
var require_toUnixPath = __commonJS({
  "src/utils/toUnixPath.js"(exports2, module2) {
    var { sep: sep2 } = require("path");
    module2.exports = function toUnixPath(originalPath = "") {
      return originalPath.split(sep2).join("/");
    };
  }
});

// src/plugin/reactPlugin/2-pageTransform/toLoaderScript.js
var require_toLoaderScript = __commonJS({
  "src/plugin/reactPlugin/2-pageTransform/toLoaderScript.js"(exports2, module2) {
    var { stringify } = require("javascript-stringify");
    var toUnixPath = require_toUnixPath();
    var { PACKAGES } = require_consts();
    module2.exports = function toLoaderScript({ componentPath, hydrate, id, props = {} }) {
      const componentImportStatement = JSON.stringify(toUnixPath(componentPath));
      if (hydrate === "eager") {
        return `<script type="module">
    import Component${id} from ${componentImportStatement};
    import { eagerLoader as eagerLoader${id} } from "${PACKAGES.client}";
  
    eagerLoader${id}({ 
      id: "${id}",
      Component: Component${id},
      props: ${stringify(props)},
    });
  <\/script>`;
      } else if (hydrate === "lazy") {
        return `<script type="module">
    import { lazyLoader as lazyLoader${id} } from "${PACKAGES.client}";
  
    lazyLoader${id}({ 
      id: "${id}",
      componentImporter: async () => await import(${componentImportStatement}),
      props: ${stringify(props)},
    });
  <\/script>`;
      } else {
        throw "Unsupported loader";
      }
    };
  }
});

// src/plugin/reactPlugin/2-pageTransform/toHydrationLoadersApplied.js
var require_toHydrationLoadersApplied = __commonJS({
  "src/plugin/reactPlugin/2-pageTransform/toHydrationLoadersApplied.js"(exports2, module2) {
    var { parse } = require("node-html-parser");
    var applyHtmlWrapper = require_applyHtmlWrapper();
    var { SLINKITY_REACT_MOUNT_POINT, PACKAGES } = require_consts();
    var toLoaderScript = require_toLoaderScript();
    var { log } = require_logger();
    var webComponentLoader = `
<script type="module">
  import { MountPoint } from "${PACKAGES.client}";
  window.customElements.define("${SLINKITY_REACT_MOUNT_POINT}", MountPoint);
<\/script>`;
    var errorMessage = ({
      inputPath,
      stacktrace
    }) => `We failed to render components used in file ${inputPath}
We recommend trying to:
1. delete your output directory and restart the server / build
2. clear your node_modules and running a clean install with "npm i"

Visit https://slinkity.dev to review our changelogs!
Stacktrace:
${stacktrace}`;
    async function toHydrationLoadersApplied({ content, componentAttrs, dir }) {
      const root = parse(content);
      applyHtmlWrapper(root);
      try {
        const scripts = componentAttrs.map(({ path: componentPath, hydrate, id, props }) => toLoaderScript({
          componentPath,
          hydrate,
          id,
          props
        }));
        root.querySelector("body").insertAdjacentHTML("beforeend", [...componentAttrs.length ? [webComponentLoader] : [], ...scripts].join("\n"));
      } catch (e) {
        if (e == null ? void 0 : e.message) {
          log({
            type: "error",
            message: errorMessage({ inputPath: dir.input, stacktrace: e.message })
          });
        }
        return root.outerHTML;
      }
      return root.outerHTML;
    }
    module2.exports = {
      toHydrationLoadersApplied,
      webComponentLoader
    };
  }
});

// src/plugin/reactPlugin/2-pageTransform/index.js
var require_pageTransform = __commonJS({
  "src/plugin/reactPlugin/2-pageTransform/index.js"(exports2, module2) {
    var { toHydrationLoadersApplied } = require_toHydrationLoadersApplied();
    module2.exports = {
      toHydrationLoadersApplied
    };
  }
});

// src/plugin/reactPlugin/1-pluginDefinitions/toRendererHtml.js
var require_toRendererHtml = __commonJS({
  "src/plugin/reactPlugin/1-pluginDefinitions/toRendererHtml.js"(exports2, module2) {
    var toBasicMinified = (str = "") => str.replace(/\n/g, "").trim();
    function toRendererHtml({ Component, hydrate, props = {}, innerHTML = "" }) {
      const parseHtmlToReact = require("html-react-parser");
      const { renderToString, renderToStaticMarkup } = require("react-dom/server");
      const reactElement = require("react").createElement(Component, props, parseHtmlToReact(innerHTML || ""));
      const elementAsHTMLString = hydrate === "static" ? renderToStaticMarkup(reactElement) : renderToString(reactElement);
      return toBasicMinified(elementAsHTMLString);
    }
    module2.exports = {
      toRendererHtml
    };
  }
});

// src/plugin/applyViteHtmlTransform.js
var require_applyViteHtmlTransform = __commonJS({
  "src/plugin/applyViteHtmlTransform.js"(exports2, module2) {
    var { parse } = require("node-html-parser");
    var { SLINKITY_ATTRS } = require_consts();
    var { toRendererHtml } = require_toRendererHtml();
    var toSlashesTrimmed = require_toSlashesTrimmed();
    var { relative: relative2 } = require("path");
    async function applyViteHtmlTransform({ content, outputPath, componentAttrStore }, { dir, viteSSR, environment }) {
      var _a;
      if (!outputPath || !outputPath.endsWith(".html")) {
        return content;
      }
      const root = parse(content);
      const mountPointsToSSR = root.querySelectorAll(`[${SLINKITY_ATTRS.ssr}="true"]`);
      const allComponentAttrsForPage = componentAttrStore.getAllByPage(outputPath);
      const pageStyles = {};
      for (const mountPointToSSR of mountPointsToSSR) {
        const id = mountPointToSSR.getAttribute(SLINKITY_ATTRS.id);
        const componentAttrs = allComponentAttrsForPage[id];
        if (componentAttrs) {
          const { path: componentPath, props, hydrate } = componentAttrs;
          const { default: Component, __stylesGenerated } = await viteSSR.toCommonJSModule(componentPath);
          Object.assign(pageStyles, __stylesGenerated);
          mountPointToSSR.innerHTML = toRendererHtml({
            Component,
            props,
            hydrate
          });
        }
      }
      (_a = root.querySelector("body")) == null ? void 0 : _a.insertAdjacentHTML("beforeend", `<style>${Object.values(pageStyles).join("\n")}</style>`);
      const routePath = "/" + toSlashesTrimmed(relative2(dir.output, outputPath));
      const server = viteSSR.getServer();
      return environment === "dev" && server ? server.transformIndexHtml(routePath, root.outerHTML) : root.outerHTML;
    }
    module2.exports = { applyViteHtmlTransform };
  }
});

// src/plugin/index.js
var require_plugin = __commonJS({
  "src/plugin/index.js"(exports2, module2) {
    var browserSync = require("browser-sync");
    var { relative: relative2, join } = require("path");
    var reactPlugin = require_reactPlugin();
    var toSlashesTrimmed = require_toSlashesTrimmed();
    var { getResolvedAliases } = require_vite();
    var { toComponentAttrStore } = require_componentAttrStore();
    var { toHydrationLoadersApplied } = require_pageTransform();
    var { applyViteHtmlTransform } = require_applyViteHtmlTransform();
    var extensions = [
      {
        extension: "jsx",
        isTemplateFormat: true,
        isIgnoredFromIncludes: true
      },
      {
        extension: "css",
        isTemplateFormat: false,
        isIgnoredFromIncludes: true
      },
      {
        extension: "scss",
        isTemplateFormat: false,
        isIgnoredFromIncludes: true
      }
    ];
    function toEleventyIgnored(userEleventyIgnores, dir) {
      const defaultIgnoredExts = extensions.filter((entry) => entry.isIgnoredFromIncludes).map((entry) => join(dir.input, dir.includes, `**/*.${entry.extension}`));
      return typeof userEleventyIgnores === "function" ? userEleventyIgnores(defaultIgnoredExts) : userEleventyIgnores != null ? userEleventyIgnores : defaultIgnoredExts;
    }
    module2.exports = function slinkityConfig(_a) {
      var _b = _a, { userSlinkityConfig } = _b, options2 = __objRest(_b, ["userSlinkityConfig"]);
      const { dir, viteSSR, browserSyncOptions, environment } = options2;
      const eleventyIgnored = toEleventyIgnored(userSlinkityConfig.eleventyIgnores, dir);
      const componentAttrStore = toComponentAttrStore();
      return function(eleventyConfig) {
        eleventyConfig.addTemplateFormats(extensions.filter((ext) => ext.isTemplateFormat).map((ext) => ext.extension));
        for (const ignored of eleventyIgnored) {
          eleventyConfig.ignores.add(ignored);
        }
        eleventyConfig.addPlugin(reactPlugin, {
          viteSSR,
          componentAttrStore,
          resolvedImportAliases: getResolvedAliases(dir)
        });
        eleventyConfig.addTransform("apply-react-hydration-loaders", async function(content, outputPath) {
          if (!outputPath || !outputPath.endsWith(".html"))
            return content;
          const componentAttrs = componentAttrStore.getAllByPage(outputPath).filter(({ hydrate }) => hydrate !== "static");
          return await toHydrationLoadersApplied({
            content,
            componentAttrs,
            dir
          });
        });
        if (environment === "dev") {
          const urlToOutputHtmlMap = {};
          eleventyConfig.on("beforeBuild", () => {
            componentAttrStore.clear();
          });
          eleventyConfig.on("afterBuild", async () => {
            let server = viteSSR.getServer();
            if (!server) {
              server = await viteSSR.createServer();
              browserSync.create();
              browserSync.init(__spreadProps(__spreadValues({}, browserSyncOptions), {
                middleware: [
                  async function viteTransformMiddleware(req, res, next) {
                    const page = urlToOutputHtmlMap[toSlashesTrimmed(req.originalUrl)];
                    if (page) {
                      const { content, outputPath } = page;
                      res.write(await applyViteHtmlTransform({ content, outputPath, componentAttrStore }, options2));
                      res.end();
                    } else {
                      next();
                    }
                  },
                  server.middlewares
                ]
              }));
            }
          });
          eleventyConfig.addTransform("update-url-to-compiled-html-map", function(content, outputPath) {
            const relativePath = relative2(dir.output, outputPath);
            const formattedAsUrl = toSlashesTrimmed(relativePath.replace(/.html$/, "").replace(/index$/, ""));
            urlToOutputHtmlMap[formattedAsUrl] = {
              outputPath,
              content
            };
            return content;
          });
        }
        if (environment === "prod") {
          eleventyConfig.addTransform("apply-vite", async function(content, outputPath) {
            return await applyViteHtmlTransform({ content, outputPath, componentAttrStore }, options2);
          });
        }
        return {};
      };
    };
  }
});

// src/cli/eleventy.js
var require_eleventy = __commonJS({
  "src/cli/eleventy.js"(exports2, module2) {
    var Eleventy = require("@11ty/eleventy/src/Eleventy");
    var EleventyErrorHandler = require("@11ty/eleventy/src/EleventyErrorHandler");
    var UserConfig = require("@11ty/eleventy/src/UserConfig");
    var { resolve: resolve2 } = require("path");
    var toViteSSR = require_toViteSSR();
    var { readUserSlinkityConfig } = require_readUserSlinkityConfig();
    var slinkityConfig = require_plugin();
    function toUserConfig(configPath = "") {
      let userConfig;
      try {
        userConfig = require(resolve2(configPath));
        return userConfig;
      } catch {
        return null;
      }
    }
    function toEleventyConfigDir2({ configPath = "", input = null, output = null }) {
      var _a, _b, _c, _d, _e;
      const userConfig = toUserConfig(configPath);
      const defaultDir = {
        input: ".",
        output: "_site",
        includes: "_includes",
        layouts: "_includes"
      };
      let userConfigDir2 = {};
      if (typeof userConfig === "function") {
        userConfigDir2 = (_b = (_a = userConfig == null ? void 0 : userConfig(new UserConfig())) == null ? void 0 : _a.dir) != null ? _b : {};
      } else if (typeof userConfig === "object") {
        userConfigDir2 = (_c = userConfig == null ? void 0 : userConfig.dir) != null ? _c : {};
      }
      return __spreadProps(__spreadValues(__spreadValues({}, defaultDir), userConfigDir2), {
        input: (_d = input != null ? input : userConfigDir2.input) != null ? _d : defaultDir.input,
        output: (_e = output != null ? output : userConfigDir2.output) != null ? _e : defaultDir.output
      });
    }
    function toBrowserSyncOptions({ outputDir, port }) {
      return {
        server: outputDir,
        port: port || 8080,
        ignore: ["node_modules"],
        watch: false,
        open: false,
        notify: false,
        ui: false,
        ghostMode: false,
        index: "index.html"
      };
    }
    function applyUserConfigDir(dir = {}) {
      return async function startEleventy2(options2 = {}) {
        if (process.env.DEBUG) {
          require("time-require");
        }
        const errorHandler = new EleventyErrorHandler();
        process.on("unhandledRejection", (error) => {
          errorHandler.fatal(error, "Unhandled rejection in promise");
        });
        process.on("uncaughtException", (error) => {
          errorHandler.fatal(error, "Uncaught exception");
        });
        process.on("rejectionHandled", (promise) => {
          errorHandler.warn(promise, "A promise rejection was handled asynchronously");
        });
        const environment = options2.watch ? "dev" : "prod";
        const config = slinkityConfig({
          dir,
          environment,
          viteSSR: await toViteSSR({ dir, environment }),
          userSlinkityConfig: await readUserSlinkityConfig(),
          browserSyncOptions: toBrowserSyncOptions({ port: options2.port, outputDir: dir.output })
        });
        let elev = new Eleventy(dir.input, dir.output, {
          quietMode: options2.quiet,
          configPath: options2.config,
          config,
          source: "cli"
        });
        elev.setPathPrefix(options2.pathprefix);
        elev.setDryRun(options2.dryrun);
        elev.setIncrementalBuild(options2.incremental);
        elev.setPassthroughAll(options2.passthroughall);
        elev.setFormats(options2.formats);
        await elev.init();
        if (options2.watch) {
          await elev.watch();
        } else {
          await elev.write();
        }
      };
    }
    module2.exports = { toEleventyConfigDir: toEleventyConfigDir2, startEleventy: applyUserConfigDir };
  }
});

// package.json
var require_package = __commonJS({
  "package.json"(exports2, module2) {
    module2.exports = {
      name: "slinkity",
      description: "To 11ty and beyond! The all-in-one tool for templates where you want them, component frameworks where you need them",
      version: "0.4.2",
      license: "MIT",
      main: "./index.js",
      types: "./index.d.ts",
      files: [
        "src/client",
        "client.js"
      ],
      homepage: "https://slinkity.dev",
      author: {
        name: "Ben Holmes",
        email: "hey@bholmes.dev",
        url: "https://bholmes.dev/"
      },
      bin: {
        slinkity: "./lib/cli/index.js"
      },
      engines: {
        node: ">=14"
      },
      keywords: [
        "static-site-generator",
        "static-site",
        "ssg",
        "documentation",
        "website",
        "jekyll",
        "blog",
        "templates",
        "generator",
        "framework",
        "eleventy",
        "eleventy-plugin",
        "11ty",
        "html",
        "markdown",
        "liquid",
        "nunjucks",
        "pug",
        "handlebars",
        "mustache",
        "ejs",
        "haml",
        "react",
        "vite",
        "bundler"
      ],
      repository: {
        type: "git",
        url: "git://github.com/slinkity/slinkity.git"
      },
      bugs: "https://github.com/slinkity/slinkity/issues",
      dependencies: {
        commander: "^5.1.0",
        esbuild: "^0.12.29",
        "esbuild-css-modules-plugin": "^2.0.7",
        "fs-extra": "^10.0.0",
        glob: "^7.1.7",
        "html-react-parser": "^1.2.7",
        "javascript-stringify": "^2.1.0",
        "node-html-parser": "^5.1.0",
        "require-from-string": "^2.0.2",
        sass: "^1.36.0",
        vite: "^2.4.4"
      },
      peerDependencies: {
        "@11ty/eleventy": "^1.0.0-beta.3"
      },
      devDependencies: {
        "@babel/core": "^7.15.0",
        "@babel/preset-env": "^7.15.0",
        "@babel/preset-react": "^7.14.5",
        "babel-jest": "^27.1.0",
        "browser-sync": "^2.27.5",
        eslint: "^7.32.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-prettier": "^3.4.0",
        "eslint-plugin-react": "^7.24.0",
        faker: "^5.5.3",
        jest: "^27.0.6",
        "npm-run-all": "^4.1.5",
        prettier: "^2.3.2",
        react: "^17.0.2",
        "react-dom": "^17.0.2",
        typescript: "^4.4.4"
      },
      scripts: {
        "build:src": "node build.js",
        "build:types": "tsc",
        build: "run-s build:src build:types",
        dev: "node build.js --watch",
        prepare: "npm run build",
        watch: "babel src -d lib -w",
        lint: 'eslint "src/**/*.{js,jsx,mjs}"',
        "lint:fix": 'eslint --fix "src/**/*.{js,jsx,mjs}"',
        test: "jest",
        "test:watch": "jest --watch"
      },
      jest: {
        roots: [
          "<rootDir>/src/"
        ]
      },
      volta: {
        node: "14.18.1"
      }
    };
  }
});

// src/cli/index.js
var { program } = require("commander");
var { relative, resolve, sep } = require("path");
var { emptyDir, mkdtemp, remove } = require("fs-extra");
var { startEleventy, toEleventyConfigDir } = require_eleventy();
var meta = require_package();
var { build: viteBuild } = require_vite();
var eleventyArgs = {
  input: {
    flag: "--input <input>",
    description: "Input template files (defaults to eleventy config or `.`)"
  },
  output: {
    flag: "--output <output>",
    description: "Write HTML output to this folder (defaults to eleventy config or `_site`)"
  },
  watch: {
    flag: "--watch",
    description: "Wait for files to change and automatically rewrite (no web server)"
  },
  formats: {
    flag: "--formats <formats>",
    description: "Whitelist only certain template types"
  },
  quiet: {
    flag: "--quiet",
    description: "Don\u2019t print all written files (off by default)"
  },
  pathprefix: {
    flag: "--pathprefix <pathprefix>",
    description: "Change all url template filters to use this subdirectory.",
    defaultValue: "/"
  },
  dryrun: {
    flag: "--dryrun",
    description: "Don\u2019t write any files. Useful with `DEBUG=Eleventy* npx eleventy`"
  },
  incremental: {
    flag: "--incremental",
    description: "Use eleventy incremental builds"
  },
  config: {
    flag: "--config <config>",
    description: "Override the eleventy config file path",
    defaultValue: ".eleventy.js"
  }
};
var slinkityArgs = {
  serve: {
    flag: "--serve",
    description: "Run Vite server and watch for file changes. Configure server options + production build options by creating a vite.config.js at the base of your project"
  },
  port: {
    flag: "--port <port>",
    description: "Port for Vite server (default: 3000)"
  }
};
var applyOption = (option) => program.option(option.flag, option.description, option.defaultValue);
var toEleventyOptions = (allOptions) => {
  const eleventyOptions = {};
  for (let [name, value] of Object.entries(allOptions)) {
    if (eleventyArgs[name] != null) {
      eleventyOptions[name] = value;
    }
    if (name === "serve" && value === true) {
      eleventyOptions.watch = true;
    }
  }
  return eleventyOptions;
};
program.version(meta.version);
applyOption(eleventyArgs.input);
applyOption(eleventyArgs.output);
applyOption(eleventyArgs.watch);
applyOption(slinkityArgs.serve);
applyOption(slinkityArgs.port);
applyOption(eleventyArgs.incremental);
applyOption(eleventyArgs.formats);
applyOption(eleventyArgs.quiet);
applyOption(eleventyArgs.config);
applyOption(eleventyArgs.pathprefix);
applyOption(eleventyArgs.dryrun);
program.parse();
var options = program.opts();
var userConfigDir = toEleventyConfigDir({
  configPath: options.config,
  input: options.input,
  output: options.output
});
(async () => {
  const outputDir = resolve(userConfigDir.output);
  await emptyDir(outputDir);
  if (options.serve) {
    const eleventyDir = __spreadValues({}, userConfigDir);
    await startEleventy(eleventyDir)(toEleventyOptions(options));
  } else {
    const intermediateDir = relative(".", await mkdtemp(".11ty-build-"));
    await startEleventy(__spreadProps(__spreadValues({}, userConfigDir), {
      output: intermediateDir.split(sep).join("/")
    }))(toEleventyOptions(options));
    await viteBuild({
      eleventyDir: userConfigDir,
      input: intermediateDir,
      output: outputDir
    });
    await remove(intermediateDir);
  }
})();
